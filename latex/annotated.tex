\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::basic\+\_\+subrt} }{\pageref{interfacepde__objs_1_1basic__subrt}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::bc\+\_\+fnc} \\*Abstract interface for boundary value function }{\pageref{interfacepde__objs_1_1bc__fnc}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::boundary\+\_\+vals} \\*Data structure to carry boundary value problem setup, allocation starts at 100 }{\pageref{structpde__objs_1_1boundary__vals}}{}
\item\contentsline{section}{{\bf decomp\+\_\+vars\+::cluster} }{\pageref{structdecomp__vars_1_1cluster}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::configuration} \\*Structure with basic model configuration }{\pageref{structglobal__objs_1_1configuration}}{}
\item\contentsline{section}{{\bf globals2d\+::crossection} \\*Structure to define crossection points }{\pageref{structglobals2d_1_1crossection}}{}
\item\contentsline{section}{{\bf decomp\+\_\+vars\+::ddinfo\+\_\+str} }{\pageref{structdecomp__vars_1_1ddinfo__str}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::dirglob\+\_\+str} }{\pageref{structglobal__objs_1_1dirglob__str}}{}
\item\contentsline{section}{{\bf decomp\+\_\+vars\+::disjoint\+\_\+nd\+\_\+str} \\*Array map with a disjoint map of subdomains, }{\pageref{structdecomp__vars_1_1disjoint__nd__str}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::element} \\*Mesh array type for elements }{\pageref{structglobal__objs_1_1element}}{}
\item\contentsline{section}{{\bf sparsematrix\+::elemt} \\*Typ pro prvek ridke matice }{\pageref{structsparsematrix_1_1elemt}}{}
\item\contentsline{section}{{\bf sparsematrix\+\_\+int\+::elemt\+\_\+int} \\*Typ pro prvek ridke matice }{\pageref{structsparsematrix__int_1_1elemt__int}}{}
\item\contentsline{section}{{\bf dual\+\_\+globals\+::exch\+\_\+k} \\*Exchange parameters }{\pageref{structdual__globals_1_1exch__k}}{}
\item\contentsline{section}{{\bf dual\+\_\+globals\+::expar} \\*Exchange parameters according to Gerke and van Genuchten (1993) }{\pageref{structdual__globals_1_1expar}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::extsmtx} }{\pageref{structglobal__objs_1_1extsmtx}}{}
\item\contentsline{section}{{\bf readtools\+::fileread} }{\pageref{interfacereadtools_1_1fileread}}{}
\item\contentsline{section}{{\bf integral\+::formulka} }{\pageref{structintegral_1_1formulka}}{}
\item\contentsline{section}{{\bf fullmatrix\+::fullmtx} \\*Plna matice }{\pageref{structfullmatrix_1_1fullmtx}}{}
\item\contentsline{section}{{\bf typy\+::funroot} \\*Koren pro funkce }{\pageref{structtypy_1_1funroot}}{}
\item\contentsline{section}{{\bf mtx\+::geti} \\*Interface pro ziskani prvku }{\pageref{interfacemtx_1_1geti}}{}
\item\contentsline{section}{{\bf mtx\+\_\+int\+::geti} \\*Interface pro ziskani prvku }{\pageref{interfacemtx__int_1_1geti}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::getval\+\_\+str} }{\pageref{interfacepde__objs_1_1getval__str}}{}
\item\contentsline{section}{{\bf heat\+\_\+globals\+::heatpars\+\_\+str} \\*A\+DE solute/material parameters array }{\pageref{structheat__globals_1_1heatpars__str}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::icond\+\_\+fnc} }{\pageref{interfacepde__objs_1_1icond__fnc}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::integnodes} }{\pageref{structglobal__objs_1_1integnodes}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::integpnt\+\_\+str} \\*Structure that specifies the point }{\pageref{structglobal__objs_1_1integpnt__str}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::logical\+\_\+fnc} }{\pageref{interfacepde__objs_1_1logical__fnc}}{}
\item\contentsline{section}{{\bf mtx\+::matrix} \\*Obecna matice }{\pageref{structmtx_1_1matrix}}{}
\item\contentsline{section}{{\bf mtx\+\_\+int\+::matrix\+\_\+int} \\*Obecna matice }{\pageref{structmtx__int_1_1matrix__int}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::matrix\+\_\+solver} }{\pageref{interfacepde__objs_1_1matrix__solver}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::measured} }{\pageref{structglobal__objs_1_1measured}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::node} \\*Mesh array type for node kolik = number of nodes id = id number of node, equal to position data = x,y coordinates bc = boundary condition for current node edge = boundary id number, if the node lies apart from any boundary, default value is 0 results = final iteration at each time step will be copied into this vector }{\pageref{structglobal__objs_1_1node}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::observation} \\*Structure to define observation points }{\pageref{structglobal__objs_1_1observation}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::observe\+\_\+info\+\_\+str} }{\pageref{structglobal__objs_1_1observe__info__str}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::observe\+\_\+time\+\_\+str} }{\pageref{structglobal__objs_1_1observe__time__str}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::pde\+\_\+common\+\_\+str} }{\pageref{structpde__objs_1_1pde__common__str}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::pde\+\_\+fnc} }{\pageref{structpde__objs_1_1pde__fnc}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::pde\+\_\+str} \\*Type definition for common quasilinear partial diferential equation in a format \[ E(u)\frac{\partial u}{\partial t} = \nabla . D(u) \nabla u - \nabla . (c(u) u) + r(u) u \] }{\pageref{structpde__objs_1_1pde__str}}{}
\item\contentsline{section}{{\bf objfnc\+::point\+\_\+str} }{\pageref{structobjfnc_1_1point__str}}{}
\item\contentsline{section}{{\bf debug\+\_\+tools\+::printmtx} }{\pageref{interfacedebug__tools_1_1printmtx}}{}
\item\contentsline{section}{{\bf objfnc\+::ram\+\_\+limit\+\_\+str} }{\pageref{structobjfnc_1_1ram__limit__str}}{}
\item\contentsline{section}{{\bf re\+\_\+globals\+::rcza} \\*Rcza structure }{\pageref{structre__globals_1_1rcza}}{}
\item\contentsline{section}{{\bf mtxiotools\+::read\+\_\+vector} }{\pageref{interfacemtxiotools_1_1read__vector}}{}
\item\contentsline{section}{{\bf pmatools\+::readint} }{\pageref{interfacepmatools_1_1readint}}{}
\item\contentsline{section}{{\bf decomp\+\_\+vars\+::resvct\+\_\+str} }{\pageref{structdecomp__vars_1_1resvct__str}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::scalar\+\_\+fnc} \\*Abstract interface for scalar function }{\pageref{interfacepde__objs_1_1scalar__fnc}}{}
\item\contentsline{section}{{\bf mtx\+::seti} \\*Interface pro nastaveni prvku }{\pageref{interfacemtx_1_1seti}}{}
\item\contentsline{section}{{\bf mtx\+\_\+int\+::seti} \\*Interface pro nastaveni prvku }{\pageref{interfacemtx__int_1_1seti}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::smartarray\+\_\+int} \\*Smart array, you don\textquotesingle{}t need to allocate -- usefull if you don\textquotesingle{}t know how many data you will write in, it is simply smart enough, it does all allocations automatically. By default the array data allocates on dimension 2, if the data doesn\textquotesingle{}t fit into this array, then the array is reallocated for a double of its original size }{\pageref{structglobal__objs_1_1smartarray__int}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::smartarray\+\_\+real} \\*For comments and description see \doxyref{smartarray\+\_\+int}{p.}{structglobal__objs_1_1smartarray__int} }{\pageref{structglobal__objs_1_1smartarray__real}}{}
\item\contentsline{section}{{\bf sparsematrix\+::smtx} \\*Ridka matice }{\pageref{structsparsematrix_1_1smtx}}{}
\item\contentsline{section}{{\bf sparsematrix\+\_\+int\+::smtx\+\_\+int} \\*Ridka matice }{\pageref{structsparsematrix__int_1_1smtx__int}}{}
\item\contentsline{section}{{\bf dual\+\_\+globals\+::soilpar} \\*Defining soil parameters }{\pageref{structdual__globals_1_1soilpar}}{}
\item\contentsline{section}{{\bf re\+\_\+globals\+::soilpar} }{\pageref{structre__globals_1_1soilpar}}{}
\item\contentsline{section}{{\bf ade\+\_\+globals\+::solutexsoil} \\*A\+DE solute/material parameters array }{\pageref{structade__globals_1_1solutexsoil}}{}
\item\contentsline{section}{{\bf ade\+\_\+globals\+::sorption\+\_\+str} \\*Parameters of sorption model }{\pageref{structade__globals_1_1sorption__str}}{}
\item\contentsline{section}{{\bf typy\+::stringlist} \\*Seznam retezcu }{\pageref{structtypy_1_1stringlist}}{}
\item\contentsline{section}{{\bf decomp\+\_\+vars\+::subdomain\+\_\+str} }{\pageref{structdecomp__vars_1_1subdomain__str}}{}
\item\contentsline{section}{{\bf typy\+::tcount} \\*Pocitadlo operaci }{\pageref{structtypy_1_1tcount}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::tensor\+\_\+fnc} \\*Abstract interface for vector function }{\pageref{interfacepde__objs_1_1tensor__fnc}}{}
\item\contentsline{section}{{\bf typy\+::tident} \\*Typ pro retezec s promennou delkou }{\pageref{structtypy_1_1tident}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::time\+\_\+check} }{\pageref{interfacepde__objs_1_1time__check}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::timeint\+\_\+fnc} }{\pageref{interfacepde__objs_1_1timeint__fnc}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::treat\+\_\+pde\+\_\+subrt} }{\pageref{interfacepde__objs_1_1treat__pde__subrt}}{}
\item\contentsline{section}{{\bf pde\+\_\+objs\+::vector\+\_\+fnc} \\*Abstract interface for vector function }{\pageref{interfacepde__objs_1_1vector__fnc}}{}
\item\contentsline{section}{{\bf global\+\_\+objs\+::version} }{\pageref{structglobal__objs_1_1version}}{}
\item\contentsline{section}{{\bf solvers\+::vrstvy} }{\pageref{structsolvers_1_1vrstvy}}{}
\item\contentsline{section}{{\bf mtxiotools\+::write\+\_\+vector} }{\pageref{interfacemtxiotools_1_1write__vector}}{}
\end{DoxyCompactList}
