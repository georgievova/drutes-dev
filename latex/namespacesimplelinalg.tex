\section{simplelinalg Module Reference}
\label{namespacesimplelinalg}\index{simplelinalg@{simplelinalg}}
\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine, public {\bf diag\+\_\+precond} (a, x, prmt, mode)
\begin{DoxyCompactList}\small\item\em right hand side diagonal preconditioner -\/ preprocessor and postprocesor preforms the diagonal matrix scaling as described in Kuraz \& Mayer\+: Algorithms for solving Darcian flow in structured porous media \end{DoxyCompactList}\item 
subroutine, public {\bf invert\+\_\+matrix} (A)
\begin{DoxyCompactList}\small\item\em subroutine, that evaluates inverse matrix up to dimension 3 \end{DoxyCompactList}\item 
real(kind=rkind) function, private {\bf determinant} (A)
\begin{DoxyCompactList}\small\item\em the matrix dimension must be exactly (2,2) or (3,3) \end{DoxyCompactList}\item 
integer(kind=ikind) function, public {\bf factorial} (in)
\end{DoxyCompactItemize}


\subsection{Function/\+Subroutine Documentation}
\index{simplelinalg@{simplelinalg}!determinant@{determinant}}
\index{determinant@{determinant}!simplelinalg@{simplelinalg}}
\subsubsection[{determinant(\+A)}]{\setlength{\rightskip}{0pt plus 5cm}real(kind=rkind) function, private simplelinalg\+::determinant (
\begin{DoxyParamCaption}
\item[{real(kind=rkind), dimension(\+:,\+:), intent(in)}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{namespacesimplelinalg_aff5df8bb70d5cb7a47e0846d391e2dae}


the matrix dimension must be exactly (2,2) or (3,3) 



Definition at line 149 of file simplelinalg.\+f90.



Referenced by invert\+\_\+matrix().


\begin{DoxyCode}
149       \textcolor{keywordtype}{use }typy
150 
151 
152       \textcolor{keywordtype}{real(kind=rkind)} :: det
153       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(:,:)}, \textcolor{keywordtype}{intent(in)} :: a
154 
155 
156       \textcolor{keywordflow}{if} (ubound(a,1) /= ubound(a,2)) \textcolor{keywordflow}{then}
157         print *, \textcolor{stringliteral}{"ERROR: input matrix is not a square matrix, called from fem\_tools::determinant()"}
158         error stop
159 \textcolor{keywordflow}{      end if}
160 
161 
162       \textcolor{keywordflow}{select case}(ubound(a,1))
163         \textcolor{keywordflow}{case}(2)
164               det = a(1,1)*a(2,2) - a(1,2)*a(2,1)
165         \textcolor{keywordflow}{case}(3)
166               det = a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1) + a(1,3)\textcolor{comment}{*a(2,1)*a(3,2)&}
167 \textcolor{comment}{                  - a(1,3)*a(2,2)*a(3,1) - a(1,2)*a(2,1)*a(3,3) - a(1,1)*a(2,3)*a(3,2)}
168 \textcolor{comment}{}\textcolor{keywordflow}{        case default}
169               print *, \textcolor{stringliteral}{"ERROR: incorrect matrix dimension, called from fem\_tools::determinant()"}
170               error stop
171 \textcolor{keywordflow}{      end select}
172 
173 
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimplelinalg_aff5df8bb70d5cb7a47e0846d391e2dae_icgraph}
\end{center}
\end{figure}


\index{simplelinalg@{simplelinalg}!diag\+\_\+precond@{diag\+\_\+precond}}
\index{diag\+\_\+precond@{diag\+\_\+precond}!simplelinalg@{simplelinalg}}
\subsubsection[{diag\+\_\+precond(a, x, prmt, mode)}]{\setlength{\rightskip}{0pt plus 5cm}subroutine, public simplelinalg\+::diag\+\_\+precond (
\begin{DoxyParamCaption}
\item[{class({\bf extsmtx}), intent(inout)}]{a, }
\item[{real(kind=rkind), dimension(\+:), intent(inout), optional}]{x, }
\item[{integer(kind=ikind), dimension(\+:), intent(in), optional}]{prmt, }
\item[{integer, intent(in)}]{mode}
\end{DoxyParamCaption}
)}\label{namespacesimplelinalg_a991176c9132fd1f9a1e494dfe43be159}


right hand side diagonal preconditioner -\/ preprocessor and postprocesor preforms the diagonal matrix scaling as described in Kuraz \& Mayer\+: Algorithms for solving Darcian flow in structured porous media 

the postprocesor performs following operation with the vector of solution \[ \mathbf{x} = \mathbf{x} \times \frac{1}{\mathbf{a_{diag}}} \] where a\+\_\+diag is a vector of diagonal values in solution matrix ~\newline
 parameter mode defines the preprocessing or postprocessing mode for this routine


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em a} & matrix in sparse format\\
\hline
\mbox{\tt in,out}  & {\em x} & the solution vector to be passed into zero iteration, it is formed out of the solution in previous time step level\\
\hline
\mbox{\tt in}  & {\em prmt} & permut vector, usefull for domain decomposition \\
\hline
\end{DoxyParams}


Definition at line 19 of file simplelinalg.\+f90.



References globals\+::drutes\+\_\+config.



Referenced by schwarz\+\_\+dd\+::schwarz\+\_\+picard(), schwarz\+\_\+dd\+\_\+time\+\_\+test\+::schwarzloc(), femmat\+::solve\+\_\+picard(), schwarz\+\_\+dd2subcyc\+::solve\+\_\+subdomain(), and subcycling\+::subcyc\+\_\+schwarz().


\begin{DoxyCode}
19       \textcolor{keywordtype}{use }typy
20       \textcolor{keywordtype}{use }sparsematrix
21       \textcolor{keywordtype}{use }globals
22       \textcolor{keywordtype}{use }globals2d
23       \textcolor{keywordtype}{use }debug_tools
24 
26       \textcolor{keywordtype}{class}(extsmtx), \textcolor{keywordtype}{intent(in out)} :: a
28       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in out)}, \textcolor{keywordtype}{optional} :: x
30       \textcolor{keywordtype}{integer(kind=ikind)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: prmt
35       \textcolor{keywordtype}{integer}, \textcolor{keywordtype}{intent(in)} :: mode
36       \textcolor{keywordtype}{integer(kind=ikind)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{allocatable}, \textcolor{keywordtype}{save} :: indexes
37       \textcolor{keywordtype}{integer(kind=ikind)} :: i, finn, finm, nelem, j, k, diag\_row
38       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{allocatable}, \textcolor{keywordtype}{save} :: values
39       \textcolor{keywordtype}{real(kind=rkind)} :: tmp
40       
41       finn=a%getn()
42       finm=a%getm()
43 
44       \textcolor{keywordflow}{if} (.not. \textcolor{keyword}{allocated}(indexes)) \textcolor{keywordflow}{then}
45         \textcolor{keyword}{allocate}(indexes(2*drutes_config%dimen+1))
46         \textcolor{keyword}{allocate}(values(2*drutes_config%dimen+1))
47 \textcolor{keywordflow}{      end if}
48 
49 
50       \textcolor{keywordflow}{if} (.not. \textcolor{keyword}{allocated}(a%weight)) \textcolor{keywordflow}{then}
51         \textcolor{keyword}{allocate}(a%weight(finm))
52 \textcolor{keywordflow}{      end if}
53       
54       \textcolor{keywordflow}{select case}(mode)
55         \textcolor{keywordflow}{case}(1)
56             a%weighted = .true.
57             \textcolor{keywordflow}{do} i=1, finm
58               \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(prmt)) \textcolor{keywordflow}{then}
59                 diag\_row = prmt(i)
60               \textcolor{keywordflow}{else}
61                 diag\_row = i
62 \textcolor{keywordflow}{              end if}
63               a%weight(i) = 1.0\_rkind/a%get(diag\_row,i)
64 \textcolor{keywordflow}{            end do}
65 
66             \textcolor{keywordflow}{do} i=1, finn
67               \textcolor{keyword}{call }a%getrow(i=i, v=values, jj=indexes, nelem=nelem)
68               \textcolor{keywordflow}{do} k=1, nelem
69                 j = indexes(k)
70                 tmp = a%get(i,j)
71                 \textcolor{keyword}{call }a%set(tmp*a%weight(j),i,j)
72 \textcolor{keywordflow}{              end do}
73 \textcolor{keywordflow}{            end do}
74     
75             \textcolor{keywordflow}{if} (\textcolor{keyword}{present}(x)) \textcolor{keywordflow}{then}
76               x(1:finm) = x(1:finm)/a%weight(1:finm)
77 \textcolor{keywordflow}{            end if}
78   
79   \textcolor{comment}{!           do i=1, ubound(a%vals,1)}
80   \textcolor{comment}{!             if (a%jj(i) > 0) then}
81   \textcolor{comment}{!               a%vals(i) = a%weight(a%jj(i))*a%vals(i)}
82   \textcolor{comment}{!             end if}
83   \textcolor{comment}{!           end do}
84   
85   \textcolor{comment}{! }
86   \textcolor{comment}{!           x(:,4) = x(:,3)/a%weight(1:ubound(x,1))}
87               
88 
89 \textcolor{comment}{!         call printmtx(a) ; stop}
90         \textcolor{keywordflow}{case}(-1)
91           \textcolor{keywordflow}{if} (.not. a%weighted) \textcolor{keywordflow}{then}
92             error stop \textcolor{stringliteral}{"ERROR the matrix was not priorly diagonalized, called from
       simplelinalg::diag\_precond"}
93 \textcolor{keywordflow}{          end if}
94 
95           \textcolor{keywordflow}{if} (.not. \textcolor{keyword}{present}(x)) \textcolor{keywordflow}{then}
96             print *, \textcolor{stringliteral}{"x-vector not present, incorrect function call, called from
       simplelinalg::diag\_precond"}
97             error stop
98 \textcolor{keywordflow}{          end if}
99 
100           x(1:finm)=x(1:finm)*a%weight
101 
102           \textcolor{keywordflow}{do} i=1, finn
103             \textcolor{keyword}{call }a%getrow(i=i, v=values, jj=indexes, nelem=nelem)
104             \textcolor{keywordflow}{do} k=1, nelem
105               j = indexes(k)
106               tmp = a%get(i,j)
107               \textcolor{keyword}{call }a%set(tmp/a%weight(j),i,j)
108 \textcolor{keywordflow}{            end do}
109 \textcolor{keywordflow}{          end do}
110           a%weighted = .false.
111 
112 \textcolor{keywordflow}{        case default}
113           print *, \textcolor{stringliteral}{"RUNTIME error in parameter mode passed into procedure fem\_tools::diag\_precond"}
114           error stop
115 \textcolor{keywordflow}{      end select}
116 
117 
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimplelinalg_a991176c9132fd1f9a1e494dfe43be159_icgraph}
\end{center}
\end{figure}


\index{simplelinalg@{simplelinalg}!factorial@{factorial}}
\index{factorial@{factorial}!simplelinalg@{simplelinalg}}
\subsubsection[{factorial(in)}]{\setlength{\rightskip}{0pt plus 5cm}integer(kind=ikind) function, public simplelinalg\+::factorial (
\begin{DoxyParamCaption}
\item[{integer(kind=ikind), intent(in)}]{in}
\end{DoxyParamCaption}
)}\label{namespacesimplelinalg_a31a21ac01f396fb59a9aad3ef9c51801}


Definition at line 177 of file simplelinalg.\+f90.


\begin{DoxyCode}
177       \textcolor{keywordtype}{use }typy
178       
179       \textcolor{keywordtype}{integer(kind=ikind)}, \textcolor{keywordtype}{intent(in)} :: in
180       \textcolor{keywordtype}{integer(kind=ikind)} :: fact
181       
182       \textcolor{keywordtype}{integer(kind=ikind)} :: i
183       
184       fact = in
185       \textcolor{keywordflow}{do} i=in-1, 1, -1
186         fact = fact*i
187 \textcolor{keywordflow}{      end do}
188       
\end{DoxyCode}
\index{simplelinalg@{simplelinalg}!invert\+\_\+matrix@{invert\+\_\+matrix}}
\index{invert\+\_\+matrix@{invert\+\_\+matrix}!simplelinalg@{simplelinalg}}
\subsubsection[{invert\+\_\+matrix(\+A)}]{\setlength{\rightskip}{0pt plus 5cm}subroutine, public simplelinalg\+::invert\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{real(kind=rkind), dimension(\+:,\+:), intent(inout)}]{A}
\end{DoxyParamCaption}
)}\label{namespacesimplelinalg_a443d39cabe9830ddbb7e553cb510cad4}


subroutine, that evaluates inverse matrix up to dimension 3 



Definition at line 122 of file simplelinalg.\+f90.



References determinant().



Referenced by fem\+\_\+tools\+::icond4neumann().


\begin{DoxyCode}
122       \textcolor{keywordtype}{use }typy
123 
124 
125       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(:,:)}, \textcolor{keywordtype}{intent(in out)} :: a
126       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(3,3)} :: a\_loc
127       \textcolor{keywordtype}{integer(kind=ikind)} :: i,j, n
128 
129       n = ubound(a,1)
130 
131       \textcolor{keywordflow}{select case}(n)
132         \textcolor{keywordflow}{case}(1)
133             a(1,1) = 1.0\_rkind/a(1,1)
134         \textcolor{keywordflow}{case}(2)
135             a\_loc(1:n,1:n) = a
136             a(1,1) = 1.0\_rkind/determinant(a\_loc(1:2,1:2))*a\_loc(2,2)
137             a(1,2) = -1.0\_rkind/determinant(a\_loc(1:2,1:2))*a\_loc(1,2)
138             a(2,1) = -1.0\_rkind/determinant(a\_loc(1:2,1:2))*a\_loc(2,1)
139             a(2,2) =  1.0\_rkind/determinant(a\_loc(1:2,1:2))*a\_loc(1,1)
140         \textcolor{keywordflow}{case}(3)
141             print *, \textcolor{stringliteral}{"no implemented, terminated from fem\_tools::invert\_matrix"}
142             error stop
143 \textcolor{keywordflow}{      end select}
144 
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=303pt]{namespacesimplelinalg_a443d39cabe9830ddbb7e553cb510cad4_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacesimplelinalg_a443d39cabe9830ddbb7e553cb510cad4_icgraph}
\end{center}
\end{figure}


