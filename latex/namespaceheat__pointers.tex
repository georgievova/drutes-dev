\section{heat\+\_\+pointers Module Reference}
\label{namespaceheat__pointers}\index{heat\+\_\+pointers@{heat\+\_\+pointers}}


heat conduction based on (Sopohocleous, 1979) \[ C\frac{\partial T}{\partial t} = \mathbf{\lambda} \Delta T - C_w \nabla \cdot \vec{q} T \]  


\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine, public {\bf heat} (pde\+\_\+loc)
\item 
real(kind=rkind) function {\bf heat\+\_\+source} (pde\+\_\+loc, layer, quadpnt, x)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
heat conduction based on (Sopohocleous, 1979) \[ C\frac{\partial T}{\partial t} = \mathbf{\lambda} \Delta T - C_w \nabla \cdot \vec{q} T \] 

\subsection{Function/\+Subroutine Documentation}
\index{heat\+\_\+pointers@{heat\+\_\+pointers}!heat@{heat}}
\index{heat@{heat}!heat\+\_\+pointers@{heat\+\_\+pointers}}
\subsubsection[{heat(pde\+\_\+loc)}]{\setlength{\rightskip}{0pt plus 5cm}subroutine, public heat\+\_\+pointers\+::heat (
\begin{DoxyParamCaption}
\item[{class({\bf pde\+\_\+str}), intent(inout)}]{pde\+\_\+loc}
\end{DoxyParamCaption}
)}\label{namespaceheat__pointers_a722171d0f13e6c6c18092dfdbca69220}


Definition at line 11 of file heat\+\_\+pointers.\+f90.



References heat\+\_\+fnc\+::heat\+\_\+conduct(), heat\+\_\+fnc\+::heat\+\_\+convect(), heat\+\_\+fnc\+::heat\+\_\+dirichlet(), heat\+\_\+fnc\+::heat\+\_\+elast(), heat\+\_\+fnc\+::heat\+\_\+flux(), heat\+\_\+fnc\+::heat\+\_\+icond(), heat\+\_\+fnc\+::heat\+\_\+neumann(), heat\+\_\+reader\+::heat\+\_\+read(), heat\+\_\+fnc\+::heat\+\_\+source(), and pde\+\_\+objs\+::pde\+\_\+common.



Referenced by manage\+\_\+pointers\+::set\+\_\+pointers().


\begin{DoxyCode}
11       \textcolor{keywordtype}{use }typy
12       \textcolor{keywordtype}{use }globals
13       \textcolor{keywordtype}{use }global_objs
14       \textcolor{keywordtype}{use }pde_objs
15       \textcolor{keywordtype}{use }heat_fnc
16       \textcolor{keywordtype}{use }heat_reader
17       
18       \textcolor{keywordtype}{class}(pde_str), \textcolor{keywordtype}{intent(in out)} :: pde\_loc
19       \textcolor{keywordtype}{integer(kind=ikind)} :: i
20       
21       \textcolor{keyword}{call }heat_read(pde\_loc)
22       
23       pde_common%nonlinear = .false. 
24             
25       pde\_loc%pde\_fnc(pde\_loc%order)%dispersion => heat_conduct
26       
27       pde\_loc%pde\_fnc(pde\_loc%order)%convection => heat_convect
28 
29       pde\_loc%pde\_fnc(pde\_loc%order)%elasticity => heat_elast
30             
31       pde\_loc%pde\_fnc(pde\_loc%order)%zerord => heat_source
32       
33           
34       \textcolor{keywordflow}{do} i=lbound(pde\_loc%bc,1), ubound(pde\_loc%bc,1)
35         \textcolor{keywordflow}{select case}(pde\_loc%bc(i)%code)
36           \textcolor{keywordflow}{case}(1)
37             pde\_loc%bc(i)%value\_fnc => heat_dirichlet
38           \textcolor{keywordflow}{case}(2)
39             pde\_loc%bc(i)%value\_fnc => heat_neumann
40 \textcolor{keywordflow}{        end select}
41 \textcolor{keywordflow}{      end do}    
42         
43       pde\_loc%flux => heat_flux
44       
45       pde\_loc%initcond => heat_icond  
46       
47     
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceheat__pointers_a722171d0f13e6c6c18092dfdbca69220_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceheat__pointers_a722171d0f13e6c6c18092dfdbca69220_icgraph}
\end{center}
\end{figure}


\index{heat\+\_\+pointers@{heat\+\_\+pointers}!heat\+\_\+source@{heat\+\_\+source}}
\index{heat\+\_\+source@{heat\+\_\+source}!heat\+\_\+pointers@{heat\+\_\+pointers}}
\subsubsection[{heat\+\_\+source(pde\+\_\+loc, layer, quadpnt, x)}]{\setlength{\rightskip}{0pt plus 5cm}real(kind=rkind) function heat\+\_\+pointers\+::heat\+\_\+source (
\begin{DoxyParamCaption}
\item[{class({\bf pde\+\_\+str}), intent(in)}]{pde\+\_\+loc, }
\item[{integer(kind=ikind), intent(in)}]{layer, }
\item[{type({\bf integpnt\+\_\+str}), intent(in), optional}]{quadpnt, }
\item[{real(kind=rkind), dimension(\+:), intent(in), optional}]{x}
\end{DoxyParamCaption}
)}\label{namespaceheat__pointers_a7890ac0e65bc5d10130112acffaf86c4}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & value of the nonlinear function\\
\hline
\mbox{\tt in}  & {\em quadpnt} & Gauss quadrature point structure (element number and rank of Gauss quadrature point)\\
\hline
\mbox{\tt in}  & {\em layer} & material ID\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return value 
\end{DoxyReturn}


Definition at line 51 of file heat\+\_\+pointers.\+f90.



References ade\+\_\+globals\+::adepar, and pde\+\_\+objs\+::pde.


\begin{DoxyCode}
51       \textcolor{keywordtype}{use }typy
52       \textcolor{keywordtype}{use }global_objs
53       \textcolor{keywordtype}{use }pde_objs
54       \textcolor{keywordtype}{use }ade_globals
55       
56       \textcolor{keywordtype}{class}(pde_str), \textcolor{keywordtype}{intent(in)} :: pde\_loc
58       \textcolor{keywordtype}{real(kind=rkind)}, \textcolor{keywordtype}{dimension(:)}, \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional}    :: x
60       \textcolor{keywordtype}{type}(integpnt_str), \textcolor{keywordtype}{intent(in)}, \textcolor{keywordtype}{optional} :: quadpnt
62       \textcolor{keywordtype}{integer(kind=ikind)}, \textcolor{keywordtype}{intent(in)} :: layer
64       \textcolor{keywordtype}{real(kind=rkind)}                :: val 
65       
66       \textcolor{keywordtype}{integer(kind=ikind)} :: n, i
67       \textcolor{keywordtype}{real(kind=rkind)} :: theta
68       
69       \textcolor{keywordflow}{if} (pde\_loc%order == 2) \textcolor{keywordflow}{then}
70         theta = pde(1)%mass(layer, quadpnt)
71       \textcolor{keywordflow}{else}
72         theta = adepar(layer)%water\_cont
73 \textcolor{keywordflow}{      end if}
74       
75        val = 0.0\_rkind
76        \textcolor{keywordflow}{do} i=1, ubound(adepar(layer)%orders,1)
77         \textcolor{keywordflow}{if} (abs(adepar(layer)%orders(i)) < 100*epsilon(1.0\_rkind)) \textcolor{keywordflow}{then}
78           val =  val + theta*adepar(layer)%lambda(i)
79 \textcolor{keywordflow}{        end if}
80 \textcolor{keywordflow}{      end do}
81       
82       
\end{DoxyCode}
